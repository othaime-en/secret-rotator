"""
Secret access control and distribution system.
Provides secure ways for applications to consume rotated secrets.
"""
import json
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from pathlib import Path
from utils.logger import logger
from encryption_manager import EncryptionManager, SecretMasker


class SecretAccessPolicy:
    """Define who/what can access which secrets"""

    def __init__(self):
        self.policies: Dict[str, Dict[str, Any]] = {}

    def add_policy(self, secret_id: str, allowed_services: List[str],
                   allowed_ips: Optional[List[str]] = None,
                   expiry_hours: Optional[int] = None):
        """Add an access policy for a secret"""
        self.policies[secret_id] = {
            "allowed_services": allowed_services,
            "allowed_ips": allowed_ips or [],
            "expiry_hours": expiry_hours,
            "created_at": datetime.now().isoformat()
        }

    def can_access(self, secret_id: str, service_name: str,
                   ip_address: Optional[str] = None) -> bool:
        """Check if a service can access a secret"""
        policy = self.policies.get(secret_id)
        if not policy:
            return False

        # Check service name
        if service_name not in policy["allowed_services"]:
            return False

        # Check IP if specified
        if policy["allowed_ips"] and ip_address:
            if ip_address not in policy["allowed_ips"]:
                return False

        # Check expiry
        if policy["expiry_hours"]:
            created = datetime.fromisoformat(policy["created_at"])
            expiry = created + timedelta(hours=policy["expiry_hours"])
            if datetime.now() > expiry:
                return False

        return True

class SecretDistributionMethod:
    """Base class for different secret distribution methods"""

    def distribute(self, secret_id: str, secret_value: str, metadata: Dict):
        """Distribute the secret to the target system"""
        raise NotImplementedError


class EnvironmentVariableDistributor(SecretDistributionMethod):
    """
    Distribute secrets as environment variables.
    Creates a .env file that applications can source.
    """

    def __init__(self, env_file: str = ".env.secrets"):
        self.env_file = Path(env_file)

    def distribute(self, secret_id: str, secret_value: str, metadata: Dict):
        """Write secret to .env file"""
        env_name = metadata.get('env_var_name', secret_id.upper())

        # Read existing content
        content = {}
        if self.env_file.exists():
            with open(self.env_file, 'r') as f:
                for line in f:
                    if '=' in line and not line.startswith('#'):
                        key, value = line.strip().split('=', 1)
                        content[key] = value

        # Update secret
        content[env_name] = secret_value

        # Write back
        with open(self.env_file, 'w') as f:
            f.write(f"# Auto-generated by Secret Rotation System\n")
            f.write(f"# Last updated: {datetime.now().isoformat()}\n\n")
            for key, value in content.items():
                f.write(f"{key}={value}\n")

        # Set restricted permissions
        import os
        os.chmod(self.env_file, 0o600)

        logger.info(f"Distributed secret {secret_id} to {self.env_file}")