"""
Secret access control and distribution system.
Provides secure ways for applications to consume rotated secrets.
"""
import json
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from pathlib import Path
from utils.logger import logger
from encryption_manager import EncryptionManager, SecretMasker


class SecretAccessPolicy:
    """Define who/what can access which secrets"""

    def __init__(self):
        self.policies: Dict[str, Dict[str, Any]] = {}

    def add_policy(self, secret_id: str, allowed_services: List[str],
                   allowed_ips: Optional[List[str]] = None,
                   expiry_hours: Optional[int] = None):
        """Add an access policy for a secret"""
        self.policies[secret_id] = {
            "allowed_services": allowed_services,
            "allowed_ips": allowed_ips or [],
            "expiry_hours": expiry_hours,
            "created_at": datetime.now().isoformat()
        }

    def can_access(self, secret_id: str, service_name: str,
                   ip_address: Optional[str] = None) -> bool:
        """Check if a service can access a secret"""
        policy = self.policies.get(secret_id)
        if not policy:
            return False

        # Check service name
        if service_name not in policy["allowed_services"]:
            return False

        # Check IP if specified
        if policy["allowed_ips"] and ip_address:
            if ip_address not in policy["allowed_ips"]:
                return False

        # Check expiry
        if policy["expiry_hours"]:
            created = datetime.fromisoformat(policy["created_at"])
            expiry = created + timedelta(hours=policy["expiry_hours"])
            if datetime.now() > expiry:
                return False

        return True


class SecretDistributionMethod:
    """Base class for different secret distribution methods"""

    def distribute(self, secret_id: str, secret_value: str, metadata: Dict):
        """Distribute the secret to the target system"""
        raise NotImplementedError


class EnvironmentVariableDistributor(SecretDistributionMethod):
    """
    Distribute secrets as environment variables.
    Creates a .env file that applications can source.
    """

    def __init__(self, env_file: str = ".env.secrets"):
        self.env_file = Path(env_file)

    def distribute(self, secret_id: str, secret_value: str, metadata: Dict):
        """Write secret to .env file"""
        env_name = metadata.get('env_var_name', secret_id.upper())

        # Read existing content
        content = {}
        if self.env_file.exists():
            with open(self.env_file, 'r') as f:
                for line in f:
                    if '=' in line and not line.startswith('#'):
                        key, value = line.strip().split('=', 1)
                        content[key] = value

        # Update secret
        content[env_name] = secret_value

        # Write back
        with open(self.env_file, 'w') as f:
            f.write(f"# Auto-generated by Secret Rotation System\n")
            f.write(f"# Last updated: {datetime.now().isoformat()}\n\n")
            for key, value in content.items():
                f.write(f"{key}={value}\n")

        # Set restricted permissions
        import os
        os.chmod(self.env_file, 0o600)

        logger.info(f"Distributed secret {secret_id} to {self.env_file}")


class ConfigFileDistributor(SecretDistributionMethod):
    """
    Distribute secrets to application config files.
    Supports JSON, YAML, TOML formats.
    """

    def __init__(self, config_file: str, file_format: str = "json"):
        self.config_file = Path(config_file)
        self.file_format = file_format.lower()

    def distribute(self, secret_id: str, secret_value: str, metadata: Dict):
        """Update secret in config file"""
        config_path = metadata.get('config_path', secret_id)

        # Read existing config
        if self.config_file.exists():
            config = self._read_config()
        else:
            config = {}

        # Update secret using dot notation path
        self._set_nested_value(config, config_path, secret_value)

        # Write back
        self._write_config(config)

        logger.info(f"Distributed secret {secret_id} to {self.config_file}")

    def _read_config(self) -> Dict:
        """Read config file based on format"""
        with open(self.config_file, 'r') as f:
            if self.file_format == "json":
                return json.load(f)
            elif self.file_format == "yaml":
                import yaml
                return yaml.safe_load(f)
            elif self.file_format == "toml":
                import toml
                return toml.load(f)
        return {}

    def _write_config(self, config: Dict):
        """Write config file based on format"""
        with open(self.config_file, 'w') as f:
            if self.file_format == "json":
                json.dump(config, f, indent=2)
            elif self.file_format == "yaml":
                import yaml
                yaml.dump(config, f, default_flow_style=False)
            elif self.file_format == "toml":
                import toml
                toml.dump(config, f)

    def _set_nested_value(self, d: Dict, path: str, value: Any):
        """Set a nested dictionary value using dot notation"""
        keys = path.split('.')
        for key in keys[:-1]:
            d = d.setdefault(key, {})
        d[keys[-1]] = value


class SecretAPIDistributor(SecretDistributionMethod):
    """
    Distribute secrets via HTTP API endpoint.
    Applications can pull secrets from this endpoint.
    """

    def __init__(self, api_url: str, auth_token: str):
        self.api_url = api_url
        self.auth_token = auth_token

    def distribute(self, secret_id: str, secret_value: str, metadata: Dict):
        """Push secret to API endpoint"""
        import requests

        headers = {
            "Authorization": f"Bearer {self.auth_token}",
            "Content-Type": "application/json"
        }

        payload = {
            "secret_id": secret_id,
            "value": secret_value,
            "rotated_at": datetime.now().isoformat(),
            "metadata": metadata
        }

        try:
            response = requests.post(
                f"{self.api_url}/secrets/{secret_id}",
                json=payload,
                headers=headers,
                timeout=10
            )
            response.raise_for_status()
            logger.info(f"Distributed secret {secret_id} to API endpoint")
        except Exception as e:
            logger.error(f"Failed to distribute secret via API: {e}")
            raise